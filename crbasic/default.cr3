''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' Biogenic VOCs and Secondary Organic Aerosol at PROPHET - WSU 2014
' 
' Data acquisition for FIS and associated micrometeorological sensors
'
' Laboratory for Atmospheric Research
' Department of Civil & Environmental Engineering
' Washington State University
'
' Contact: Patrick O'Keeffe <pokeeffe@wsu.edu>
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''

'manually update VERSION with results of `git describe` prior to pushing to
'datalogger but do not check-in file with other than empty string
Const VERSION = ""


'=========================== CONST TABLE SETTINGS ============================
ConstTable
  Const FLUSH_TUBE_ID = 0.5 'I.D. of flush line, inches
  Const SDM_SPEED = 30 'usec; 8-3000

  Const UTC_OFFSET = -5 'Eastern Standard Time
  Const SONIC2_ENABLED = True  
  Const SONIC2_ADDR = 3 'default SDM address
  Const SONIC3_ENABLED = True 
  Const SONIC3_ADDR = 4 '<-- change sonic config
EndConstTable


'============================== WIRING =======================================

Const FIS_PMT_COM = Com1  'C1/C2  photomuliplier tube (PMT)
Const FIS_FLOW_TOT_DF = 1 'differential analog inputs
Const FIS_FLOW_O2_DF = 2
Const FIS_FLOW_STD_DF = 3
Const FIS_STATE_STD_SE = 27 'single-ended analog inputs
Const FIS_STATE_ZERO_SE = 28
Const FIS_CTRL_STD_CAO = 1 'continuous analog outputs
Const FIS_CTRL_ZERO_CAO = 2

Const TSI_COM = Com2 'C3/C4  TSI flowmeter

Const WXT_COM = 5 'C5 (SDI)

Const GPS_COM = Com4 'C7/C8

'============================== CONSTANTS ====================================
Const CR = CHR(13) 'carriage return
Const PI = 3.14159
Const L_PER_FT3 = 28.316847 'vol. conversion

Const MW_CO2 = 44.010   'molecular weight of carbon dioxide, g/mol
Const MW_H2O = 18.01528 'molecular weight of water vapor, g/mol
Const R_AIR = 287.058   'specific gas constant for dry air, J/(kg K)
Const R_ = 8.3144621e-6 'universal gas constant, (kPa m^3)/(K mmol)

'part of Sutherland's fomula for deriving dynamic viscosity of air
Const SU_CONST = 120 'K
Const LAMBDA_AIR = 1.512041288 'uPa s K^-1/2

Const TUBE_AREA = PI*FLUSH_TUBE_ID*FLUSH_TUBE_ID/4 'in^2

'Operational configuration
Const FAST_INTV = 100 'ms = 10 Hz
Const WXT_INTV = 15 'sec
Const STATS_INTV = 30 'min
Const INTEG = 250
Const STOPRING = 0 'CardOut: 0-ring mode, 1-stop fill

'FIS photomultiplier tube
Const PMT_INTEG = 10  '# of 10ms intervals to sum per reading; = 10 Hz
Const PMT_BAUD = 9600
Const PMT_FORMAT = 3  '8/none/1 in "binary" mode
Const PMT_BUFF = 10  '4 bytes/reading * 2 + 1
Const PMT_CMD_SETINTEG = "P" & CHR(PMT_INTEG) & CR  'set integration time
Const PMT_CMD_SETVOLTAGE = "D" & CR  'set default high voltage
Const PMT_CMD_START = "C" & CR  'begin continuous read
Const PMT_CMD_STOP = CR

'FIS etc
Const FIS_FLOW_TOT_MULT = (10-0)/(5000-0) '0-10 sLpm / 0-5V
Const FIS_FLOW_TOT_OFFSET = 0
Const FIS_FLOW_O2_MULT = (2-0)/(5000-0) '0-2 sLpm / 0-5V
Const FIS_FLOW_O2_OFFSET = 0
Const FIS_FLOW_STD_MULT = (20-0)/(5000-0) '0-20 sccm / 0-5V
Const FIS_FLOW_STD_OFFSET = 0

'GPS receiver
Const MAX_DIFF = 25 'msec
Const DAILY_MEDNUM = 480 

'SDM devices
Const EC100_ADDR = 1 'default SDM address
Const EC100_CMD = 1 'get 3D wind, temp, CO2, H2O, press & 2 diagnostics
Const CSAT3_CMD = 91 'trigger + get 3D wind, temp & diagnostic
Const CSAT3_OPT = INT(1000/FAST_INTV)

'SDI device
Const WXT_ADDR = 0   'SDI address
Const WXT_CMD = "C!" 'initiate concurrent measurements --> composite msg
Const WXT_MEDNUM = (STATS_INTV*60)/WXT_INTV 'max # of values to include in Median()

Const TSI_BAUD = 38400
Const TSI_FORMAT = 3  '8/none/1 in "binary mode"
Const TSI_BUFF = 19  '2*(9 char/rec) + 1
Const TSI_QUERY = "DBFTP0001"+CR 'request 1 binary record
Const TSI_BEGINWORD = &h80000000 'special null byte representation
Const TSI_ENDWORD = &hFFFF
Const TSI_STP_T = 21.1 'degC
Const TSI_STP_P = 101.3 'kPa

Const DEF_SONIC1_AZIMUTH = -1  'default settings values
Const DEF_SONIC2_AZIMUTH = -1
Const DEF_SONIC3_AZIMUTH = -1
Const DEF_WXT_AZIMUTH = -1
Const DEF_SONIC1_HEIGHT = 0
Const DEF_SONIC2_HEIGHT = 0
Const DEF_SONIC3_HEIGHT = 0
Const DEF_WXT_HEIGHT = 0
Const DEF_FLUSH_TUBE_LENGTH = 0
Const DEF_FIS_STD_CONC = 0
Const DEF_FIS_CAL_INTERVAL = 8 'hr
Const DEF_FIS_CAL_ZERO_DUR = 4 'min
Const DEF_FIS_CAL_BOTH_DUR = 4 'min
Const DEF_FIS_CAL_STD_DUR = 0 'min
Const DEF_FIS_CAL_SFILT = 60+55 'sec
Const DEF_FIS_CAL_EFILT = 5 'sec


'============================= VARIABLES =====================================
Dim pmt_record As String * 4
Dim pmt_bytes
Dim pmt_convert As Long

Public FIS_pmt_overflow As Boolean
Public FIS_pmt_counts
Units FIS_pmt_counts = counts

Public fis_flow(4)
Alias fis_flow(1) = FIS_flow_tot
Alias fis_flow(2) = FIS_flow_samp
Alias fis_flow(3) = FIS_flow_O2
Alias fis_flow(4) = FIS_flow_std
Units FIS_flow_tot = sLpm
Units FIS_flow_samp = sLpm
Units FIS_flow_O2 = sLpm
Units FIS_flow_std = sccm

Public FIS_cal_event As Long 'dual role incremental counter / flag
Public fis_status(3) As Boolean
Alias fis_status(1) = FIS_std_ON
Alias fis_status(2) = FIS_zero_ON
Alias fis_status(3) = FIS_cal_filter

Dim fis_sched(8) As Long 'use Long to stop annoying compiler warnings
Alias fis_sched(1) = cal_int
Alias fis_sched(2) = cal_shift
Alias fis_sched(3) = turn_zero_on
Alias fis_sched(4) = turn_std_on
Alias fis_sched(5) = turn_zero_off
Alias fis_sched(6) = turn_std_off
Alias fis_sched(7) = filter_off
Alias fis_sched(8) = filter_on
Units fis_sched = sec

Dim fis_ctrl(2) 'HACK for sending TTL with CAO b/c too few control ports
Alias fis_ctrl(1) = FIS_ctrl_zero
Alias fis_ctrl(2) = FIS_ctrl_std
Dim fis_state(2) 'HACK for reading TTL with SE 27,28 b/c too few control ports
Alias fis_state(1) = FIS_state_std
Alias fis_state(2) = FIS_state_zero

Public disable_sonic1 As Boolean
Public disable_irga1 As Boolean
Public sonic_irga(12)
Alias sonic_irga(1)  = sonic1_Ux
Alias sonic_irga(2)  = sonic1_Uy
Alias sonic_irga(3)  = sonic1_Uz
Alias sonic_irga(4)  = sonic1_Ts
Alias sonic_irga(5)  = sonic1_diag
Alias sonic_irga(6)  = irga1_CO2
Alias sonic_irga(7)  = irga1_H2O
Alias sonic_irga(8)  = irga1_diag
Alias sonic_irga(9)  = irga1_amb_tmpr
Alias sonic_irga(10) = irga1_amb_press
Alias sonic_irga(11) = irga1_CO2_signal
Alias sonic_irga(12) = irga1_H2O_signal
Units sonic1_Ux = m/s
Units sonic1_Uy = m/s
Units sonic1_Uz = m/s
Units sonic1_Ts = degC
Units sonic1_diag = bitmap
Units irga1_CO2 = mmol/m^3
Units irga1_H2O = mmol/m^3
Units irga1_diag = bitmap
Units irga1_amb_tmpr = degC
Units irga1_amb_press = kPa
Units irga1_CO2_signal = ratio
Units irga1_H2O_signal = ratio

Public irga1_Xco2_Avg
Units irga1_Xco2_Avg = ppm

#If (SONIC2_ENABLED) Then
  Public disable_sonic2 As Boolean
  Public sonic2(5)
  Alias sonic2(1) = sonic2_Ux
  Alias sonic2(2) = sonic2_Uy
  Alias sonic2(3) = sonic2_Uz
  Alias sonic2(4) = sonic2_Ts
  Alias sonic2(5) = sonic2_diag
  Units sonic2 = m/s
  Units sonic2_Ts = degC
  Units sonic2_diag = bitmap
#EndIf

#If (SONIC3_ENABLED) Then
  Public disable_sonic3 As Boolean
  Public sonic3(5)
  Alias sonic3(1) = sonic3_Ux
  Alias sonic3(2) = sonic3_Uy
  Alias sonic3(3) = sonic3_Uz
  Alias sonic3(4) = sonic3_Ts
  Alias sonic3(5) = sonic3_diag
  Units sonic3 = m/s
  Units sonic3_Ts = degC
  Units sonic3_diag = bitmap
#EndIf

Dim wxt_scaling(8) = {1, 1, 1, 1, 0.1, 1, 1, 1} 'convert press: mbar -> kPa
Public wxt(8)
Alias wxt(1) = wxt_WD
Alias wxt(2) = wxt_WS
Alias wxt(3) = wxt_tmpr
Alias wxt(4) = wxt_RH
Alias wxt(5) = wxt_press
Alias wxt(6) = wxt_rain_amt
Alias wxt(7) = wxt_rain_dur
Alias wxt(8) = wxt_rain_int
Units wxt_WD = degrees
Units wxt_WS = m/s
Units wxt_tmpr = degC
Units wxt_RH = %
Units wxt_press = kPa
Units wxt_rain_amt = mm
Units wxt_rain_dur = sec
Units wxt_rain_int = mm/hr

Dim tsi_bytes
Dim tsi_record As String * 6
Dim tsi_words(3) As Long
Dim tmpr_msb As Long
Public tsi(3)
Alias tsi(1) = flush_massFlow
Alias tsi(2) = flush_tmpr
Alias tsi(3) = flush_press
Units flush_massFlow = sLpm
Units flush_tmpr = degC
Units flush_press = kPa

Dim tube_volume
Public tsi_etc(3)
Alias tsi_etc(1) = flush_volFlow
Alias tsi_etc(2) = flush_delay
Alias tsi_etc(3) = flush_Re
Units flush_volFlow = L/min
Units flush_delay = sec
Units flush_Re = dimless

Dim nmea_str(2) As String * 90
Public gps16x(15)
Alias gps16x(1)  = lat_deg        '(+)=North, (-)=South
Alias gps16x(2)  = lat_min
Alias gps16x(3)  = long_deg       '(+)=East, (-)=West
Alias gps16x(4)  = long_min
Alias gps16x(5)  = speed
Alias gps16x(6)  = course
Alias gps16x(7)  = mag_var        '(+)=East, (-)=West
Alias gps16x(8)  = fix_quality
Alias gps16x(9)  = num_sat
Alias gps16x(10) = altitude
Alias gps16x(11) = since_pps
Alias gps16x(12) = since_gprmc
Alias gps16x(13) = gps_ready
Alias gps16x(14) = max_clock_change
Alias gps16x(15) = num_clock_change
Units speed = m/s
Units course = degEofN
Units mag_var = degEofN
Units fix_quality = unitless
Units num_sat = count
Units altitude = m
Units since_pps = ms
Units since_gprmc = s
Units max_clock_change = ms
Units num_clock_change = occurrences

Dim i
Dim just_had_wxt_scan As Boolean
Dim inbetween_wxt_scan As Boolean

Dim dummy(4) = {0, 0, 0, 0}
Dim work_out(18)
Alias work_out(1)  = wxt_WD_Med
Alias work_out(2)  = sonic1_WS_sclr_Avg
Alias work_out(3)  = sonic1_WS_rslt_Avg
Alias work_out(4)  = sonic1_WD_rslt_Avg
Alias work_out(5)  = sonic1_WD_csi_Std
Alias work_out(6)  = sonic2_WS_sclr_Avg
Alias work_out(7)  = sonic2_WS_rslt_Avg
Alias work_out(8)  = sonic2_WD_rslt_Avg
Alias work_out(9)  = sonic2_WD_csi_Std
Alias work_out(10) = sonic3_WS_sclr_Avg
Alias work_out(11) = sonic3_WS_rslt_Avg
Alias work_out(12) = sonic3_WD_rslt_Avg
Alias work_out(13) = sonic3_WD_csi_Std
Alias work_out(14) = flush_Re_Avg
Alias work_out(15) = irga1_CO2_Avg
Alias work_out(16) = irga1_H2O_Avg
Alias work_out(17) = irga1_amb_tmpr_Avg
Alias work_out(18) = irga1_amb_press_Avg
Units wxt_WD_Med = degEofTN
Units sonic1_WS_sclr_Avg = m/s
Units sonic1_WS_rslt_Avg = m/s
Units sonic1_WD_rslt_Avg = degEofTN
Units sonic1_WD_csi_Std = degrees
Units sonic2_WS_sclr_Avg = m/s
Units sonic2_WS_rslt_Avg = m/s
Units sonic2_WD_rslt_Avg = degEofTN
Units sonic2_WD_csi_Std = degrees
Units sonic3_WS_sclr_Avg = m/s
Units sonic3_WS_rslt_Avg = m/s
Units sonic3_WD_rslt_Avg = degEofTN
Units sonic3_WD_csi_Std = degrees
Units flush_Re_Avg = dimless
Units irga1_CO2_Avg = mmol/m^3
Units irga1_H2O_Avg = mmol/m^3
Units irga1_amb_tmpr_Avg = degC
Units irga1_amb_press_Avg = kPa


'========================= SETTINGS RETENTION ================================
Dim filehandle As Long
Const CALSTUFF_FILE = "CPU:fis_calstuff.dat"
Const SETTINGS_FILE = "CPU:fis_settings.dat"
Const NUM_CALSTUFF = {2}
Const NUM_SETTINGS = {16}
Const WRITEFILE = 0
Const READFILE = 1

Dim calstuff(NUM_CALSTUFF)
Alias calstuff(1) = cal_counter
Alias calstuff(2) = cal_shift

Dim settings(NUM_SETTINGS)
Alias settings(1)  = sonic1_azimuth
Alias settings(2)  = sonic2_azimuth
Alias settings(3)  = sonic3_azimuth
Alias settings(4)  = wxt_azimuth
Alias settings(5)  = sonic1_height
Alias settings(6)  = sonic2_height
Alias settings(7)  = sonic3_height
Alias settings(8)  = wxt_height
Alias settings(9)  = flush_tube_length
Alias settings(10) = fis_std_conc
Alias settings(11) = fis_cal_interval
Alias settings(12) = fis_cal_zero_dur
Alias settings(13) = fis_cal_both_dur
Alias settings(14) = fis_cal_std_dur
Alias settings(15) = fis_cal_Sfilt
Alias settings(16) = fis_cal_Efilt
Units sonic1_azimuth = degEofTN
Units sonic2_azimuth = degEofTN
Units sonic3_azimuth = degEofTN
Units wxt_azimuth = degEofTN
Units sonic1_height = ft
Units sonic2_height = ft
Units sonic3_height = ft
Units wxt_height = ft
Units flush_tube_length = ft
Units fis_std_conc = ppm
Units fis_cal_interval = hr
Units fis_cal_zero_dur = min
Units fis_cal_both_dur = min
Units fis_cal_std_dur = min
Units fis_cal_Sfilt = sec
Units fis_cal_Efilt = sec

Dim choice(NUM_SETTINGS)
Alias choice(1)  = ch_sonic1_azimuth
Alias choice(2)  = ch_sonic2_azimuth
Alias choice(3)  = ch_sonic3_azimuth
Alias choice(4)  = ch_wxt_azimuth
Alias choice(5)  = ch_sonic1_height
Alias choice(6)  = ch_sonic2_height
Alias choice(7)  = ch_sonic3_height
Alias choice(8)  = ch_wxt_height
Alias choice(9)  = ch_flush_tube_length
Alias choice(10) = ch_fis_std_conc
Alias choice(11) = ch_fis_cal_interval
Alias choice(12) = ch_fis_cal_zero_dur
Alias choice(13) = ch_fis_cal_both_dur
Alias choice(14) = ch_fis_cal_std_dur
Alias choice(15) = ch_fis_cal_Sfilt
Alias choice(16) = ch_fis_cal_Efilt


'============================= DATA TABLES ===================================
'HINT In time-series tables, only store variables in IEEE4 or FP2 variables 
'     b/c UINT2 and Long store null values (NAN) as goofy sentinal values.
'     Presumably, if a boolean is null, something went very wrong so don't
'     worry about it and for summary tables, null values are excluded so we 
'     don't care as much about sentinal values.
DataTable(just_cals,(FIS_cal_event > 0),0)
  DataInterval(0,FAST_INTV,mSec,10)
  CardOut(STOPRING,18000) 'last 2 events
  Sample(1,FIS_pmt_counts,FP2)
  Sample(1,FIS_flow_tot,FP2)
  Sample(1,FIS_flow_O2,FP2)
  Sample(1,FIS_flow_std,FP2)
  Sample(1,FIS_zero_ON,Boolean)
  Sample(1,FIS_std_ON,Boolean)
  Sample(1,FIS_cal_filter,Boolean)
  Sample(1,FIS_cal_event,UINT2)
EndTable

DataTable(ts_fast,True,600)
  DataInterval(0,FAST_INTV,mSec,10)
  CardOut(STOPRING,-1)
  Sample(1,FIS_pmt_counts,FP2)
  Sample(1,FIS_pmt_overflow,Boolean)
  Sample(1,FIS_flow_tot,IEEE4)
  Sample(1,FIS_flow_O2,IEEE4)
  Sample(1,FIS_flow_std,IEEE4)
  Sample(1,FIS_zero_ON,Boolean)
  Sample(1,FIS_std_ON,Boolean)
  Sample(1,FIS_cal_filter,Boolean)
  Sample(1,FIS_cal_event,UINT2)
  
  Sample(1,sonic1_Ux,IEEE4)
  Sample(1,sonic1_Uy,IEEE4)
  Sample(1,sonic1_Uz,IEEE4)
  Sample(1,sonic1_Ts,IEEE4)
  Sample(1,sonic1_diag,IEEE4)
  Sample(1,irga1_CO2,IEEE4)
  Sample(1,irga1_H2O,IEEE4)
  Sample(1,irga1_amb_tmpr,IEEE4)
  Sample(1,irga1_amb_press,IEEE4)
  Sample(1,irga1_diag,FP2) 'OK, only 1 byte
  Sample(1,irga1_CO2_signal,IEEE4)
  Sample(1,irga1_H2O_signal,IEEE4)
  
  #If (SONIC2_ENABLED) Then
    Sample(1,sonic2_Ux,IEEE4)
    Sample(1,sonic2_Uy,IEEE4)
    Sample(1,sonic2_Uz,IEEE4)
    Sample(1,sonic2_Ts,IEEE4)
    Sample(1,sonic2_diag,IEEE4)
  #EndIf
  
  #If (SONIC3_ENABLED) Then
    Sample(1,sonic3_Ux,IEEE4)
    Sample(1,sonic3_Uy,IEEE4)
    Sample(1,sonic3_Uz,IEEE4)
    Sample(1,sonic3_Ts,IEEE4)
    Sample(1,sonic3_diag,IEEE4)
  #EndIf
  
  Sample(1,flush_massFlow,FP2)
  Sample(1,flush_tmpr,FP2)
  Sample(1,flush_press,FP2)
EndTable

DataTable(ts_wxt,True,8)
  DataInterval(0,WXT_INTV,Sec,10)
  CardOut(STOPRING,-1)
  Sample(1,wxt_WD,FP2)
  Sample(1,wxt_WS,FP2)
  Sample(1,wxt_tmpr,FP2)
  Sample(1,wxt_RH,FP2)
  Sample(1,wxt_press,IEEE4) 'FP2 truncates to 1 decimal place if abs val > 80
  Sample(1,wxt_rain_amt,FP2)
  Sample(1,wxt_rain_dur,FP2)
  Sample(1,wxt_rain_int,FP2)
EndTable

DataTable(work,True,2)
  TableHide
  DataInterval(0,STATS_INTV,Min,10)
  Median (1,wxt_WD,WXT_MEDNUM,FP2,wxt_WD=NAN OR inbetween_wxt_scan)
  WindVector(1,-1*sonic1_Uy,sonic1_Ux,IEEE4,disable_sonic1,0,1,2)
  #If (SONIC2_ENABLED) Then
    WindVector(1,-1*sonic2_Uy,sonic2_Ux,IEEE4,disable_sonic2,0,1,2)
  #Else
    Sample(4,dummy(1),FP2)
  #EndIf
  #If (SONIC3_ENABLED) Then
    WindVector(1,-1*sonic3_Uy,sonic3_Ux,IEEE4,disable_sonic3,0,1,2)
  #Else
    Sample(4,dummy(1),FP2)
    FieldNames("dummy2(4)")
  #EndIf
  Average(1,flush_Re,IEEE4,flush_Re=NAN)
  Average(1,irga1_CO2,IEEE4,disable_irga1)
  Average(1,irga1_H2O,IEEE4,disable_irga1)
  Average(1,irga1_amb_tmpr,IEEE4,disable_irga1 OR irga1_amb_tmpr=NAN)
  Average(1,irga1_amb_press,IEEE4,disable_irga1 OR irga1_amb_press=NAN)
EndTable

DataTable(stats,True,4)
  DataInterval(0,STATS_INTV,Min,10)
  CardOut(STOPRING,-1)
  Average(1,FIS_flow_tot,FP2,FIS_flow_tot=NAN)
  StdDev (1,FIS_flow_tot,FP2,FIS_flow_tot=NAN)
  Average(1,FIS_flow_samp,FP2,FIS_flow_samp=NAN)
  StdDev (1,FIS_flow_samp,FP2,FIS_flow_samp=NAN)
  Average(1,FIS_flow_O2,FP2,FIS_flow_O2=NAN)
  StdDev (1,FIS_flow_O2,FP2,FIS_flow_O2=NAN)
  Average(1,FIS_flow_std,FP2,FIS_flow_std=NAN OR NOT FIS_std_ON)
  StdDev (1,FIS_flow_std,FP2,FIS_flow_std=NAN OR NOT FIS_std_ON)

  Sample (1,wxt_WD_Med,FP2)
  Average(1,wxt_WS,FP2,wxt_WS=NAN OR inbetween_wxt_scan)
  Average(1,wxt_tmpr,FP2,wxt_tmpr=NAN OR inbetween_wxt_scan)
  Median (1,wxt_RH,WXT_MEDNUM,FP2,wxt_RH=NAN OR inbetween_wxt_scan)
  Average(1,wxt_press,FP2,wxt_press=NAN OR inbetween_wxt_scan)

  Average(1,flush_massFlow,FP2,flush_massFlow=NAN)
  StdDev (1,flush_massFlow,FP2,flush_massFlow=NAN)
  Average(1,flush_tmpr,FP2,flush_tmpr=NAN)
  Average(1,flush_press,FP2,flush_press=NAN)
  Average(1,flush_volFlow,FP2,flush_volFlow=NAN)
  StdDev (1,flush_volFlow,FP2,flush_volFlow=NAN)
  Average(1,flush_delay,FP2,flush_delay=NAN)
  StdDev (1,flush_delay,FP2,flush_delay=NAN)
  Sample (1,flush_Re_Avg,IEEE4)

  Average(1,sonic1_Ts,FP2,sonic1_Ts=NAN)
  StdDev (1,sonic1_Ts,FP2,sonic1_Ts=NAN)
  StdDev (1,sonic1_Uz,FP2,sonic1_Uz=NAN)
  Sample (1,sonic1_WS_sclr_Avg,FP2)
  Sample (1,sonic1_WS_rslt_Avg,FP2)
  Sample (1,sonic1_WD_rslt_Avg,FP2)
  Sample (1,sonic1_WD_csi_Std,FP2)
  Sample (1,irga1_Xco2_Avg,FP2)
  Sample (1,irga1_CO2_Avg,FP2)
  Sample (1,irga1_H2O_Avg,FP2)
  Sample (1,irga1_amb_tmpr_Avg,FP2)
  Sample (1,irga1_amb_press_Avg,FP2)
  Average(1,irga1_CO2_signal,FP2,irga1_CO2_signal=NAN)
  Average(1,irga1_H2O_signal,FP2,irga1_H2O_signal=NAN)

  #If (SONIC2_ENABLED) Then
    Average(1,sonic2_Ts,FP2,sonic2_Ts=NAN)
    StdDev (1,sonic2_Ts,FP2,sonic2_Ts=NAN)
    StdDev (1,sonic2_Uz,FP2,sonic2_Uz=NAN)
    Sample (1,sonic2_WS_sclr_Avg,FP2)
    Sample (1,sonic2_WS_rslt_Avg,FP2)
    Sample (1,sonic2_WD_rslt_Avg,FP2)
    Sample (1,sonic2_WD_csi_Std,FP2)
  #EndIf
  #If (SONIC3_ENABLED) Then
    Average(1,sonic3_Ts,FP2,sonic3_Ts=NAN)
    StdDev (1,sonic3_Ts,FP2,sonic3_Ts=NAN)
    StdDev (1,sonic3_Uz,FP2,sonic3_Uz=NAN)
    Sample (1,sonic3_WS_sclr_Avg,FP2)
    Sample (1,sonic3_WS_rslt_Avg,FP2)
    Sample (1,sonic3_WD_rslt_Avg,FP2)
    Sample (1,sonic3_WD_csi_Std,FP2)
  #EndIf
EndTable

DataTable(gps_daily,TRUE,30)
  DataInterval (0,1,Day,10)
  CardOut(STOPRING,150)
  Median(1,(lat_deg + lat_min/60),DAILY_MEDNUM,IEEE4,(lat_deg=NAN OR lat_min=NAN))
    FieldNames("latitude_Med")
    Units latitude_Med = degN
  Median(1,(long_deg + long_min/60),DAILY_MEDNUM,IEEE4,(long_deg=NAN OR long_min=NAN))
    FieldNames("longitude_Med")
    Units longitude_Med = degE
  Median(1,mag_var,DAILY_MEDNUM,FP2,mag_var=NAN)
  Average(1,num_sat,FP2,num_sat=NAN)
  Median(1,altitude,DAILY_MEDNUM,IEEE4,altitude=NAN)
  Average(1,altitude,FP2,altitude=NAN)
  Minimum(1,gps_ready,FP2,gps_ready=NAN,0)
  Sample(1,max_clock_change,UINT2)
  Sample(1,num_clock_change,UINT2)
EndTable

DataTable(info,True,100)
  CardOut(STOPRING,1000)
  Sample(1,UTC_OFFSET,FP2) 'HINT need sign so not UINT2
    FieldNames("UTC_offset")
    Units UTC_OFFSET = hours
  Sample(1,EC100_ADDR,UINT2)
    FieldNames("sonicIRGA_SDM_address")
  Sample(1,SONIC2_ADDR,UINT2)
    FieldNames("sonic2_SDM_address")
  Sample(1,SONIC3_ADDR,UINT2)
    FieldNames("sonic3_SDM_address")
  Sample(1,TSI_STP_T,FP2)
    FieldNames("flowmeter_STP_tmpr")
    Units flowmeter_STP_tmpr = degC
  Sample(1,TSI_STP_P,FP2)
    FieldNames("flowmeter_STP_press")
    Units flowmeter_STP_press = kPa
  Sample(1,sonic1_azimuth,FP2)
  Sample(1,sonic1_height,FP2)
  #If (SONIC2_ENABLED) Then
    Sample(1,sonic2_azimuth,FP2)
    Sample(1,sonic2_height,FP2)
  #EndIf
  #If (SONIC3_ENABLED) Then
    Sample(1,sonic3_azimuth,FP2)
    Sample(1,sonic3_height,FP2)
  #EndIf
  Sample(1,wxt_azimuth,FP2)
    FieldNames("wxt510_azimuth")
  Sample(1,wxt_height,FP2)
    FieldNames("wxt510_height")
  Sample(1,fis_cal_interval,FP2)
    FieldNames("FIS_cal_interval")
  Sample(1,fis_cal_zero_dur,FP2)
    FieldNames("FIS_cal_zero_dur")
  Sample(1,fis_cal_both_dur,FP2)
    FieldNames("FIS_cal_both_dur")
  Sample(1,fis_cal_std_dur,FP2)
    FieldNames("FIS_cal_std_dur")
  Sample(1,fis_cal_Sfilt,FP2)
    FieldNames("FIS_calstart_filter")
  Sample(1,fis_cal_Efilt,FP2)
    FieldNames("FIS_calend_filter")
  Sample(1,flush_tube_length,FP2)
  Sample(1,FLUSH_TUBE_ID,FP2)
    FieldNames("flush_tube_ID")
    Units FLUSH_TUBE_ID = in
  Sample(1,Status.SerialNumber,UINT2)
    FieldNames("LoggerSN")
  Sample(1,Status.OSVersion,String)
    FieldNames("OSVersion")
  Sample(1,Status.CompileResults,String)
    FieldNames("CompileResults")
  Sample(1,Status.CardStatus,String)
    FieldNames("CardStatus")
  Sample(1,Status.RunSignature,UINT2)
    FieldNames("RunSig")
  Sample(1,Status.ProgSignature,UINT2)
    FieldNames("ProgSig")
  Sample(1,VERSION,String)
    FieldNames("ProgVersion")
EndTable


'========================== CUSTOM MENUS =====================================
Const Yes = True
Const SendCommand = True
Const No = False
Const Cancel = False
Const A = 10
Const B = 11
Const C = 12
Const D = 13
Const E = 14
Dim save_changes As Boolean
Dim discard_changes As Boolean
Dim set_defaults As Boolean
Dim recompile As Boolean
Dim restart_pmt_flag As Boolean
Dim stop_pmt_flag As Boolean

DisplayMenu("FIS DAQ", -1)
  SubMenu("View FIS data")
    DisplayValue("PMT counts", FIS_pmt_counts)
    DisplayValue("PMT overflow", FIS_pmt_overflow)
    DisplayValue("Total flow", FIS_flow_tot)
    DisplayValue("O2 flow", FIS_flow_O2)
    DisplayValue("Std. flow", FIS_flow_std)
    DisplayValue("Zero is ON", FIS_zero_ON)
    DisplayValue("Std is ON", FIS_std_ON)
  EndSubMenu
  
  SubMenu("Settings")
    MenuItem("Sonic 1 azimuth", ch_sonic1_azimuth)
    MenuItem("Sonic 1 height", ch_sonic1_height)
    #If (SONIC2_ENABLED) Then
      MenuItem("Sonic 2 azimuth", ch_sonic2_azimuth)
      MenuItem("Sonic 2 height", ch_sonic2_height)
    #EndIf
    #If (SONIC3_ENABLED) Then
      MenuItem("Sonic 3 azimuth", ch_sonic3_azimuth)
      MenuItem("Sonic 3 height", ch_sonic3_height)
    #EndIf
    MenuItem("WXT510 azimuth", ch_wxt_azimuth)
    MenuItem("WXT510 height", ch_wxt_height)
    MenuItem("Flush tube length", ch_flush_tube_length)
    SubMenu("FIS Calibration")
      MenuItem("Standard conc", ch_fis_std_conc)
      MenuItem("Cal. interval", ch_fis_cal_interval)
        MenuPick(2,3,4,6,8,12)
      MenuItem("Zero duration", ch_fis_cal_zero_dur)
      MenuItem("Z+S duration", ch_fis_cal_both_dur)
      MenuItem("Std duration", ch_fis_cal_std_dur)
      MenuItem("Start filter", ch_fis_cal_Sfilt)
      MenuItem("End filter", ch_fis_cal_Efilt)
    EndSubMenu
    SubMenu("Apply/cancel")
      MenuItem("Save now?", save_changes)
        MenuPick(Cancel,Yes)
      MenuItem("Discard?", discard_changes)
        MenuPick(Cancel,Yes)
      MenuItem("Set default?", set_defaults)
        MenuPick(Cancel,Yes)
    EndSubMenu
  EndSubMenu
  
  SubMenu("FIS PMT Control")
    MenuItem("(Re)start", restart_pmt_flag)
      MenuPick(Cancel,SendCommand)
    MenuItem("Stop", stop_pmt_flag)
      MenuPick(Cancel,SendCommand)
  EndSubMenu
    
  SubMenu("Initial setup")
    'HINT do not include SDM_SPEED or FLUSH_TUBE_ID in this menu because the
    '     datalogger is too dumb to accept arbitrary input via custom menus
    MenuItem("Time zone", UTC_OFFSET)
      MenuPick(UTC_OFFSET,-8,-7,-6,-5,-4)
    MenuItem("Use sonic2?", SONIC2_ENABLED)
      MenuPick(SONIC2_ENABLED, No, Yes)
    MenuItem("sonic2 addr", SONIC2_ADDR)
      MenuPick(SONIC2_ADDR,0,2,3,4,5,6,7,8,9,A,B,C,D,E)
    MenuItem("Use sonic3?", SONIC3_ENABLED)
      MenuPick(SONIC3_ENABLED, No, Yes)
    MenuItem("sonic3 addr", SONIC3_ADDR)
      MenuPick(SONIC3_ADDR,0,2,3,4,5,6,7,8,9,A,B,C,D,E)
    MenuRecompile("Recompile?", recompile)
      MenuPick(Cancel,Yes)
  EndSubMenu
EndMenu


'============================== SUBROUTINES ==================================
Sub start_pmt()
  'TODO check if a continuous measurement is already in progress!
  '     if so, send stop command, set integ time & voltage, then restart
  SerialOut(FIS_PMT_COM,PMT_CMD_SETINTEG,"",0,0) 'set integration time
  SerialOut(FIS_PMT_COM,PMT_CMD_SETVOLTAGE,"",0,0) 'enable high voltage
  SerialOut(FIS_PMT_COM,PMT_CMD_START,"",0,0) 'begin continuous readings
EndSub

Sub stop_pmt()
  SerialOut(FIS_PMT_COM,PMT_CMD_STOP,"",0,0) 'stop continuous readings
EndSub

Sub update_cal_timers()
  'HINT fis_* prefixed are from settings array, in minutes
  turn_zero_on = cal_shift 'sec
  turn_zero_off = turn_zero_on + fis_cal_zero_dur*60 + fis_cal_both_dur*60
  turn_std_on = cal_shift + fis_cal_zero_dur*60
  turn_std_off = turn_std_on + fis_cal_both_dur*60 + fis_cal_std_dur*60
EndSub

Sub set_default_choices()
  ch_sonic1_azimuth = DEF_SONIC1_AZIMUTH
  ch_sonic2_azimuth = DEF_SONIC2_AZIMUTH
  ch_sonic3_azimuth = DEF_SONIC3_AZIMUTH
  ch_wxt_azimuth = DEF_WXT_AZIMUTH
  ch_sonic1_height = DEF_SONIC1_HEIGHT
  ch_sonic2_height = DEF_SONIC2_HEIGHT
  ch_sonic3_height = DEF_SONIC3_HEIGHT
  ch_wxt_height = DEF_WXT_HEIGHT
  ch_flush_tube_length = DEF_FLUSH_TUBE_LENGTH
  ch_fis_std_conc = DEF_FIS_STD_CONC
  ch_fis_cal_interval = DEF_FIS_CAL_INTERVAL
  ch_fis_cal_zero_dur = DEF_FIS_CAL_ZERO_DUR
  ch_fis_cal_both_dur = DEF_FIS_CAL_BOTH_DUR
  ch_fis_cal_std_dur = DEF_FIS_CAL_STD_DUR
  ch_fis_cal_Sfilt = DEF_FIS_CAL_SFILT
  ch_fis_cal_Efilt = DEF_FIS_CAL_EFILT
EndSub

Sub populate_choices()
  Move(choice(1),NUM_SETTINGS,settings(1),NUM_SETTINGS)
EndSub

Sub save_current_choices()
  Move(settings(1),NUM_SETTINGS,choice(1),NUM_SETTINGS)
  'simplest possible input validation
  If (sonic1_height < 0) Then sonic1_height = DEF_SONIC1_HEIGHT
  If (sonic2_height < 0) Then sonic2_height = DEF_SONIC2_HEIGHT
  If (sonic3_height < 0) Then sonic3_height = DEF_SONIC3_HEIGHT
  If (wxt_height < 0) Then wxt_height = DEF_WXT_HEIGHT
  If (flush_tube_length < 0) Then flush_tube_length = DEF_FLUSH_TUBE_LENGTH
  If (fis_std_conc < 0) Then fis_std_conc = DEF_FIS_STD_CONC
  If (fis_cal_interval < 0) Then fis_cal_interval = DEF_FIS_CAL_INTERVAL
  If (fis_cal_zero_dur < 0) Then fis_cal_zero_dur = DEF_FIS_CAL_ZERO_DUR
  If (fis_cal_both_dur < 0) Then fis_cal_both_dur = DEF_FIS_CAL_BOTH_DUR
  If (fis_cal_std_dur < 0) Then fis_cal_std_dur = DEF_FIS_CAL_STD_DUR
  If (fis_cal_Sfilt < 0) Then fis_cal_Sfilt = DEF_FIS_CAL_SFILT
  If (fis_cal_Efilt < 0) Then fis_cal_Efilt = DEF_FIS_CAL_EFILT

  'treat azimuths different since 0 is  valid azimuth & enforce integer vals
  sonic1_azimuth = IIF(sonic1_azimuth < 0, -1, FIX(sonic1_azimuth) MOD 360)
  sonic2_azimuth = IIF(sonic2_azimuth < 0, -1, FIX(sonic2_azimuth) MOD 360)
  sonic3_azimuth = IIF(sonic3_azimuth < 0, -1, FIX(sonic3_azimuth) MOD 360)
  wxt_azimuth = IIF(wxt_azimuth < 0, -1, FIX(wxt_azimuth) MOD 360)

  'set dependent variables
  tube_volume = flush_tube_length * TUBE_AREA/144 '(ft)(in^2)(ft^2/in^2)
  tube_volume *= L_PER_FT3
  cal_int = fis_cal_interval*3600 'hr -> sec
  update_cal_timers()

  Move(choice(1),NUM_SETTINGS,settings(1),NUM_SETTINGS)
  Calfile(settings,NUM_SETTINGS,SETTINGS_FILE,WRITEFILE)
EndSub

Sub load_settings()
  filehandle = FileOpen(SETTINGS_FILE,"rb",0)
  FileClose(filehandle)
  If (filehandle = 0) Then 'file was not found
    set_default_choices()
  Else
    Calfile(settings,NUM_SETTINGS,SETTINGS_FILE,READFILE)
    populate_choices()
  EndIf
  save_current_choices()
EndSub

Sub reset_settings()
  FileManage(SETTINGS_FILE,8) 'delete file
  load_settings()
EndSub

Sub save_calstuff()
  Calfile(calstuff,1,CALSTUFF_FILE,WRITEFILE)
EndSub

Sub load_calstuff()
  filehandle = FileOpen(CALSTUFF_FILE,"rb",0)
  FileClose(filehandle)
  If (filehandle = 0) Then 'file missing
    cal_counter = 0
    save_calstuff()
  Else
    Calfile(cal_counter,NUM_CALSTUFF,CALSTUFF_FILE,READFILE)
  EndIf
EndSub

Sub setup()
  load_settings()
  load_calstuff()
  SerialOpen(TSI_COM,TSI_BAUD,TSI_FORMAT,0,TSI_BUFF)  
  SerialOpen(FIS_PMT_COM,PMT_BAUD,PMT_FORMAT,0,PMT_BUFF)
  start_pmt()
  SDMSpeed(SDM_SPEED)
EndSub


'================================= FUNCTIONS =================================
'TSI Models 4040/4043/4045 General Purpose Thermal Mass Flowmeter Operation
'    and Service Manual. Appendix B. August 2001. Revision D
'[StdFlow] = std L/min @ TSI specs, [Tmpr] = C, [Press] = kPa
Function volumetric_flow(StdFlow, Tmpr, Press) As Float 'Lpm
  Return (StdFlow * ((273.15+Tmpr)/(273.15+TSI_STP_T)) * (TSI_STP_P/Press))
EndFunction

'[VolFlow] = L/min
Function estimate_lag(VolFlow) As Float 'sec
  Return (60 * tube_volume / VolFlow))  '(60sec/min)(L)(min/L)
EndFunction

'https://en.wikipedia.org/wiki/Viscosity
'[Tmpr] = C
Function dynamic_viscosity(Tmpr) As Float 'kg/(m*s) = Pa*s
  '(uPa*s/K^1/2)(K^3/2)(1/K) * (Pa/10^6 uPa)
  Return (LAMBDA_AIR * (Tmpr+273.15)^1.5 / ((Tmpr+273.15+SU_CONST)*10^6))
EndFunction

'[Tmpr] = C, [Press] = kPa (abs.)
Function density_of_air(Tmpr, Press) As Float 'kg/m^3
  '(Pa/kPa)(kPa)(kg*K / J)(1/K)(J / Pa*m^3)
  Return (1000*Press / (R_AIR*(Tmpr+273.15)))
EndFunction

'https://en.wikipedia.org/wiki/Reynolds_number
'[VolFlow] = L/min, [Tmpr] = C, [Press] = kPa (abs.)
'HINT return as a Float but use FIX() to drop fractional portion
Function reynolds_num(VolFlow, Tmpr, Press) As Float 'dimless
  Dim mu, rho
  mu = dynamic_viscosity(Tmpr)
  rho = density_of_air(Tmpr, Press)
  '(kg/m^3)(L/min)(in)(m*s/kg)(1/in^2) * (min/60 sec)(39.37in/m)(m^3/1000L)
  Return Round((rho*VolFlow*FLUSH_TUBE_ID*39.37)/(mu*TUBE_AREA*60*1000), -1)
EndFunction

'Derived by inverting equations in Appendix D of EC150 manual
'[Gas] = mmol/m^3, [H2O] = mmol/m^3, [Tmpr] = C, [Press] = kPa (abs.)
Function dry_mixing_ratio(Gas, H2O, Tmpr, Press) As Float 'ppm (umol/mol)
  Dim rhoair 'mmol/m^3 (don't use density_of_air(..) b/c units are so far off)
  'mmol/m^3 = (kPa)(K mmol/kPa m^3)(1/K)
  rhoair = Press/(R_ * (Tmpr + 273.15))
  'ppm = (umol/mol)(mmol/m^3) / (mmol/^3 - mmol/m^3)
  Return Round(10^6 * Gas / (rhoair - H2O), 0)
EndFunction


'=============================== PROGRAM =====================================
ShutDownBegin
  stop_pmt()
ShutDownEnd

BeginProg
  setup()
  CallTable info
  
  Scan(FAST_INTV,mSec,0,0)
    'calibration schedule
    If TimeIntoInterval(0,1,Day) Then
      cal_shift = (cal_shift + 3600) MOD cal_int 'advance 1 hr each day
      update_cal_timers()
    EndIf
    If TimeIntoInterval(turn_zero_on,cal_int,Sec) Then
      FIS_ctrl_zero = 5000 'set 5V (on)
      FIS_cal_filter = True 'activate data filter
      filter_off = turn_zero_on + fis_cal_Sfilt 'reset filter time marks
      filter_on = turn_zero_on + fis_cal_zero_dur*60 - fis_cal_Efilt
      'HINT this timer is hit first so (only once) advance the event counter
      cal_counter += 1 'increment hidden event counter
      FIS_cal_event = cal_counter 'set public event flag true (e.g. >0)
    EndIf
    If TimeIntoInterval(turn_std_on,cal_int,Sec) Then
      FIS_ctrl_std = 5000
      FIS_cal_filter = True 'catches start of "both" seq. even if both_dur=0
      filter_off = turn_std_on + fis_cal_Sfilt
      filter_on = turn_std_on + fis_cal_std_dur*60 - fis_cal_Efilt
    EndIf
    If TimeIntoInterval(turn_zero_off,cal_int,Sec) Then
      FIS_ctrl_zero = 0 'set 0V (off)
      If (fis_cal_std_dur > 0) Then 'if has std-only step, reset filter timers
        filter_off = turn_zero_off + fis_cal_Sfilt
        filter_on = turn_zero_off + fis_cal_std_dur*60 - fis_cal_Efilt
      EndIf
    EndIf
    'HINT check/set the public cal filter prior to final step in sequence to
    'ensure is is known OFF state after exiting final step
    If TimeIntoInterval(filter_off,cal_int,Sec) Then FIS_cal_filter = False
    If TimeIntoInterval(filter_on,cal_int,Sec) Then FIS_cal_filter = True
    If TimeIntoInterval(turn_std_off,cal_int,Sec) Then
      FIS_ctrl_std = 0
      'HINT guaranteed last in sequence b/c negative durations prohibited
      FIS_cal_filter = False
      FIS_cal_event = 0
    EndIf
    'logic -^ / action -v
    ExciteCAO(FIS_CTRL_ZERO_CAO,FIS_ctrl_zero,True)
    ExciteCAO(FIS_CTRL_STD_CAO,FIS_ctrl_std,True)

    EC100(sonic_irga(1),EC100_ADDR,EC100_CMD)
    disable_sonic1 = sonic1_diag > 0
    If (sonic1_Ux = -99999) Then 'HACK see changelog for v1.0.5, 1.1
      disable_sonic1 = True
      sonic1_Ux = NAN
    EndIf
    disable_irga1 = irga1_diag > 0
    If (irga1_CO2=NAN OR irga1_H2O=NAN) Then
      disable_irga1 = True
    Else
      irga1_CO2 /= MW_CO2 'mg/m^3 --> mmol/m^3
      irga1_H2O *= (1000/MW_H2O) 'g/m^3 --> mmol/m^3
    EndIf

    #If (SONIC2_ENABLED) Then
      CSAT3(sonic2(1),1,SONIC2_ADDR,CSAT3_CMD,CSAT3_OPT)
      disable_sonic2 = (sonic2_diag AND &hF000)
    #EndIf
    #If (SONIC3_ENABLED) Then
      CSAT3(sonic3(1),1,SONIC3_ADDR,CSAT3_CMD,CSAT3_OPT)
      disable_sonic3 = (sonic3_diag AND &hF000)
    #EndIf

    SerialInRecord(FIS_PMT_COM,pmt_record,0,4,0,pmt_bytes,11)
    If (pmt_bytes = 4) Then
      'check most significant bit of MSB (byte3) for overflow condition
      FIS_pmt_overflow = ASCII(pmt_record(1,1,3)) AND &h80
      If (FIS_pmt_overflow) Then
        FIS_pmt_counts = NAN
      Else
        MoveBytes(pmt_convert,0,pmt_record,3,1) 'reverse byte order
        MoveBytes(pmt_convert,1,pmt_record,2,1)
        MoveBytes(pmt_convert,2,pmt_record,1,1)
        MoveBytes(pmt_convert,3,pmt_record,0,1)
        FIS_pmt_counts = pmt_convert 'coerce to float
      EndIf
    Else
      FIS_pmt_counts = NAN
      FIS_pmt_overflow = False
    EndIf
      
    VoltDiff(FIS_flow_tot,1,mV5000,FIS_FLOW_TOT_DF,True,0,INTEG, _
                                        FIS_FLOW_TOT_MULT,FIS_FLOW_TOT_OFFSET)
    VoltDiff(FIS_flow_O2,1,mV5000,FIS_FLOW_O2_DF,True,0,INTEG, _
                                          FIS_FLOW_O2_MULT,FIS_FLOW_O2_OFFSET)
    VoltDiff(FIS_flow_std,1,mV5000,FIS_FLOW_STD_DF,True,0,INTEG, _
                                        FIS_FLOW_STD_MULT,FIS_FLOW_STD_OFFSET)
    FIS_flow_samp = FIS_flow_tot - FIS_flow_O2
    
    'pretend SE 27, SE 28 are TTL inputs
    VoltSe(FIS_state_std,1,mV5000,FIS_STATE_STD_SE,False,0,INTEG,1,0)
    VoltSe(FIS_state_zero,1,mV5000,FIS_STATE_ZERO_SE,False,0,INTEG,1,0)
    FIS_std_ON = (FIS_state_std > 2500)
    FIS_zero_ON = (FIS_state_zero > 2500)

    SerialInRecord(TSI_COM,tsi_record,TSI_BEGINWORD,0,TSI_ENDWORD,tsi_bytes,11)
    SerialOut(TSI_COM,TSI_QUERY,"",0,0) 'ask for next measurement
    MoveBytes(tsi_words(1),2,tsi_record,0,2) 'flow
    MoveBytes(tsi_words(3),2,tsi_record,4,2) 'press
    'HINT string-indexing is 1-based but MoveBytes indexing is 0-based
    tmpr_msb = ASCII(tsi_record(1,1,3)) 'grab sign & MSB as # (0-255)
    tsi_words(2) = (tmpr_msb AND &h7F) << 8 'drop sign, push into 2nd byte pos
    MoveBytes(tsi_words(2),3,tsi_record,3,1) 'move LSB into 1st byte pos
    If (tmpr_msb AND &h80) Then tsi_words(2) -= 32768 'apply sign
    For i = 1 To 3 'now scale to decimal
      tsi(i) = tsi_words(i)/100.0
    Next
    'HACK datalogger reads consecutive leading null bytes (e.g. flow = 0.00)
    'incorrectly; if abs. press is 0, then move values into correct vars
    If (flush_press <= 0) Then
      flush_press = flush_tmpr
      flush_tmpr = flush_massFlow
      flush_massFlow = 0
    EndIf
    'HACK still possible for datalogger to hiccup if MSB of flow is 0x00 so 
    'we also conduct naive sanity check on temperature value and throw out
    'data if suspect
    If (flush_tmpr > 50) Then '>122*F ?
      flush_massFlow = NAN
      flush_press = NAN
      flush_tmpr = NAN
      flush_volFlow = NAN
      flush_delay = NAN
      flush_Re = NAN
    Else
      flush_volFlow = volumetric_flow(flush_massFlow, flush_tmpr, flush_press)
      flush_delay = IIF(tube_volume > 0, estimate_lag(flush_volFlow), NAN)
      flush_Re = IIF(flush_volFlow > 0, _
                      reynolds_num(flush_volFlow, flush_tmpr, flush_press), 0)
    EndIf

    CallTable(just_cals)
    CallTable(ts_fast)
    CallTable(work)
    If (work.Output(1,1)) Then
      GetRecord(work_out(1),work,1)
      wxt_WD_Med = (Round(wxt_WD_Med, 0) + _
                                IIF(wxt_azimuth < 0, 0, wxt_azimuth)) MOD 360
      If(sonic1_WS_sclr_Avg = NAN AND sonic1_WS_rslt_Avg = NAN) Then
        sonic1_WD_rslt_Avg = NAN
        sonic1_WD_csi_Std = NAN
      Else
        sonic1_WD_rslt_Avg = (Round(sonic1_WD_rslt_Avg, 0) + _
                          IIF(sonic1_azimuth < 0, 0, sonic1_azimuth)) MOD 360 
      EndIf
      #If (SONIC2_ENABLED) Then
        If (sonic2_WS_sclr_Avg = NAN AND sonic2_WS_rslt_Avg = NAN) Then
          sonic2_WD_rslt_Avg = NAN
          sonic2_WD_csi_Std = NAN
        Else
          sonic2_WD_rslt_Avg = (Round(sonic2_WD_rslt_Avg, 0) + _
                          IIF(sonic2_azimuth < 0, 0, sonic2_azimuth)) MOD 360
        EndIf
      #EndIf
      #If (SONIC3_ENABLED) Then
        If (sonic3_WS_sclr_Avg = NAN AND sonic3_WS_rslt_Avg = NAN) Then
          sonic3_WD_rslt_Avg = NAN
          sonic3_WD_csi_Std = NAN
        Else
          sonic3_WD_rslt_Avg = (Round(sonic3_WD_rslt_Avg, 0) + _
                          IIF(sonic3_azimuth < 0, 0, sonic3_azimuth)) MOD 360
        EndIf
      #EndIf
      flush_Re_Avg = Round(flush_Re_Avg, -1)
      irga1_Xco2_Avg = dry_mixing_ratio(irga1_CO2_Avg, irga1_H2O_Avg, _
                                      irga1_amb_tmpr_Avg, irga1_amb_press_Avg)
    EndIf
    CallTable(stats)

    If (save_changes) Then
      save_current_choices()
      save_changes = Cancel
      CallTable info
    ElseIf (discard_changes) Then
      populate_choices()
      discard_changes = Cancel
      'don't save b/c no changes
    ElseIf (set_defaults) Then
      reset_settings()
      set_defaults = Cancel
      CallTable info
    ElseIf (restart_pmt_flag) Then
      start_PMT()
      restart_pmt_flag = False
    ElseIf (stop_pmt_flag) Then
      stop_PMT()
      stop_pmt_flag = False
    EndIf

    inbetween_wxt_scan = True
    If (just_had_wxt_scan) Then
      just_had_wxt_scan = False
      inbetween_wxt_scan = False
    EndIf
  NextScan
  
  SlowSequence
  Scan(WXT_INTV,Sec,10,0)
    GPS(lat_deg),GPS_COM,UTC_OFFSET*3600,MAX_DIFF,nmea_str(1))
    CallTable(gps_daily)

    SDI12Recorder(wxt(1),WXT_COM,WXT_ADDR,WXT_CMD,wxt_scaling(),0)
    'XXX despite `wxt_azimuth` setting, DO NOT correct WD values
    CallTable(ts_wxt)

    just_had_wxt_scan = True
  NextScan
EndProg

